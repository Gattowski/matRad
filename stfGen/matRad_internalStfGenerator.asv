classdef matRad_internalStfGenerator < matRad_StfGenerator

    properties (Constant)
        possibleRadiationModes = {'brachy'};
        name = 'extStfGen';
        shortName = 'extStfGen';
    end 
    
    methods
        function this = matRad_internalStfGenerator(ct, cst, pln, visMode)
              
            this@matRad_StfGenerator(ct, cst, pln, visMode);
            
            if ~isfield(pln, 'propStf')
                this.matRad_cfg.dispError('no applicator information in pln struct');
            end
            

            this = this.generate2DTemplatePoints();
            this = this.generateSeedPositions();
            this.matRad_cfg.dispInfo('Processing completed: %d%%\n', 100);
            this.visualizeResults();
            this.checkSeedPoints();
        end
        
     
        
        function this = generate2DTemplatePoints(this)
            [row, col] = find(this.pln.propStf.template.activeNeedles);
            templX = col * this.pln.propStf.bixelWidth + this.pln.propStf.templateRoot(1) - (13 + 1) / 2 * this.pln.propStf.bixelWidth;
            templY = row * this.pln.propStf.bixelWidth + this.pln.propStf.templateRoot(2) - (13 + 1) / 2 * this.pln.propStf.bixelWidth;
            templZ = ones(size(col)) + this.pln.propStf.templateRoot(3);
            
            this.stf.template = [templX'; templY'; templZ'];
            this.stf.templateNormal = [0, 0, 1];
        end
        
        function this = generateSeedPositions(this)
            d = this.pln.propStf.needle.seedDistance;
            seedsNo = this.pln.propStf.needle.seedsNo;
            needleDist(1, 1, :) = d .* (0:seedsNo - 1)'; 
            needleDir = needleDist .* [0; 0; 1];
            seedPos_coord_need_seed = needleDir + this.stf.template;
            seedPos_need_seed_coord = shiftdim(seedPos_coord_need_seed, 1);
            X = seedPos_need_seed_coord(:, :, 1);
            Y = seedPos_need_seed_coord(:, :, 2);
            Z = seedPos_need_seed_coord(:, :, 3);
            
            this.stf.seedPoints.x = reshape(X, 1, []);
            this.stf.seedPoints.y = reshape(Y, 1, []);
            this.stf.seedPoints.z = reshape(Z, 1, []);
        end
        
        function visualizeResults(this)
            if this.visMode > 0
                clf
                plot3(this.stf.seedPoints.x, this.stf.seedPoints.y, this.stf.seedPoints.z, '.', 'DisplayName', 'seed points', 'Color', 'black', 'markersize', 5);
                title('3D Visualization of seed points');
                xlabel('X (left) [mm]');
                ylabel('Y (posterior) [mm]');
                zlabel('Z (superior) [mm]');
                hold on
                
                TargX = this.stf.targetVolume.Xvox;
                TargY = this.stf.targetVolume.Yvox;
                TargZ = this.stf.targetVolume.Zvox;
                P = [TargX', TargY', TargZ'];
                
                switch exist('OCTAVE_VERSION', 'builtin')
                        case 0
                                % MATLAB environment
                                k = boundary(P, 1);
                                trisurf(k, P(:,1), P(:,2), P(:,3), 'FaceColor', 'red', 'FaceAlpha', 0.1, 'LineStyle', 'none')
                        otherwise
                                % Octave environment
   
                                [uni, ~] = sort(unique(TargX));
                                n = length(uni);
                                outline = zeros(2*n, 2);

                                                    for i = 1:n
                                                        y_list = TargY(TargX == uni(i));
                                                        y_max = max(y_list);
                                                        y_min = min(y_list);
                                                        outline(i, :) = [uni(i), y_max];
                                                        outline(2*n-i+1, :) = [uni(i), y_min];
                                                    end
                    
                    figure;
                    plot(TargX, TargY, 'b+', 'DisplayName', 'VOI Points');
                    hold on;
                    plot(outline(:, 1), outline(:, 2), 'g-', 'LineWidth', 3, 'DisplayName', 'Computed Outline');
                    area = polyarea(outline(:, 1), outline(:, 2));
                    disp(['Polygon area: ', num2str(area)]);
                    hold off;
                end
            end
        end
        
        function checkSeedPoints(this)
            if (max(this.stf.seedPoints.x - this.pln.propStf.templateRoot(1)) >= 4 * max(this.stf.targetVolume.Xvox - this.pln.propStf.templateRoot(1)) ||...
                min(this.stf.seedPoints.x - this.pln.propStf.templateRoot(1)) <= 4 * min(this.stf.targetVolume.Xvox - this.pln.propStf.templateRoot(1)) ||...
                max(this.stf.seedPoints.y - this.pln.propStf.templateRoot(2)) >= 4 * max(this.stf.targetVolume.Yvox - this.pln.propStf.templateRoot(2)) ||...
                min(this.stf.seedPoints.y - this.pln.propStf.templateRoot(2)) <= 4 * min(this.stf.targetVolume.Yvox - this.pln.propStf.templateRoot(2)) ||...
                max(this.stf.seedPoints.z - this.pln.propStf.templateRoot(3)) >= 4 * max(this.stf.targetVolume.Zvox - this.pln.propStf.templateRoot(3)) ||...
                min(this.stf.seedPoints.z - this.pln.propStf.templateRoot(3)) <= 4 * min(this.stf.targetVolume.Zvox - this.pln.propStf.templateRoot(3)))
                this.matRad_cfg.dispWarning('Seeds far outside the target volume');
            end
            
            if (max(this.stf.targetVolume.Xvox) <= min(this.stf.seedPoints.x) || min(this.stf.targetVolume.Xvox) >= max(this.stf.seedPoints.x) ||...
                max(this.stf.targetVolume.Yvox) <= min(this.stf.seedPoints.y) || min(this.stf.targetVolume.Yvox) >= max(this.stf.seedPoints.y) ||...
                max(this.stf.targetVolume.Zvox) <= min(this.stf.seedPoints.z) || min(this.stf.targetVolume.Zvox) >= max(this.stf.seedPoints.z))
                this.matRad_cfg.dispWarning('no seed points in VOI');
            end
        end
    end
end

