classdef matRad_externalStfGenerator < matRad_StfGenerator

    properties (Constant)
        possibleRadiationModes = {'protons','photons','carbon','helium'};
        name = 'extStfGen';
        shortName = 'extStfGen';
    end 
    
    properties
        SAD
        machine
    end
    
    methods
        
        function this = matRad_externalStfGenerator(ct, cst, pln, visMode)
            this@matRad_StfGenerator(ct, cst, pln, visMode);

            this.visualizeExtRadResults();
        end
           
        function loadMachine(this)
            fileName = [this.pln.radiationMode '_' this.pln.machine];
            try
                load([this.matRad_cfg.matRadRoot filesep 'basedata' filesep fileName]);
                this.SAD = this.machine.meta.SAD;
            catch
                this.matRad_cfg.dispError('Could not find the following machine file: %s', fileName);
            end
        end
        
        function particleStructure(this)
            % To be implemented in particle subclass
        end
        
        function generateStf(this)

            this.validateInputs();

            V = this.findTargetVoxels();

            voiTarget = this.generateVoiCube(V);

            voiTarget = this.addMarginIfRequired(voiTarget);

            this.loadMachine

            % loop over all rays to determine meta information for each ray    
        stf(i).numOfBixelsPerRay = ones(1,stf(i).numOfRays);
    
    for j = stf(i).numOfRays:-1:1

        for ShiftScen = 1:pln.multScen.totNumShiftScen
            % ray tracing necessary to determine depth of the target
            [alphas,l{ShiftScen},rho{ShiftScen},d12,~] = matRad_siddonRayTracer(stf(i).isoCenter + pln.multScen.isoShift(ShiftScen,:), ...
                ct.resolution, ...
                stf(i).sourcePoint, ...
                stf(i).ray(j).targetPoint, ...
                [ct.cube {voiTarget}]);
            
            %Used for generic range-shifter placement
            ctEntryPoint = alphas(1) * d12;
        end

        end

        function visualizeExtRadResults(this)

            if visMode > 0
        
            clf;
            % first subplot: visualization in bev
            subplot(1,2,1)
            hold on
        
            % plot rotated target coordinates
            plot3(rot_coords(:,1),rot_coords(:,2),rot_coords(:,3),'r.')

            end
        
            % surface rendering
            if visMode == 2
            
                % generate a 3D rectangular grid centered at isocenter in
                % voxel coordinates
                [X,Y,Z] = meshgrid((1:ct.cubeDim(2))-stf(i).isoCenter(1)/ct.resolution.x, ...
                                   (1:ct.cubeDim(1))-stf(i).isoCenter(2)/ct.resolution.y, ...
                                   (1:ct.cubeDim(3))-stf(i).isoCenter(3)/ct.resolution.z);
            
                % computes surface
                patSurfCube      = 0*ct.cube{1};
                idx              = [cst{:,4}];
                idx              = unique(vertcat(idx{:}));
                patSurfCube(idx) = 1;
            
                [f,v] = isosurface(X,Y,Z,patSurfCube,.5);
            
                % convert isosurface from voxel to [mm]
                v(:,1) = v(:,1)*ct.resolution.x;
                v(:,2) = v(:,2)*ct.resolution.y;
                v(:,3) = v(:,3)*ct.resolution.z;
            
                % rotate surface
                rotated_surface = v*rotMat_system_T;
            
                % surface rendering
                surface = patch('Faces',f,'Vertices',rotated_surface);
                set(surface,'FaceColor',[0 0 1],'EdgeColor','none','FaceAlpha',.4);
                lighting gouraud;
        
            end
        
            % plot projection matrix: coordinates at isocenter
            plot3(rayPos(:,1),rayPos(:,2),rayPos(:,3),'k.');
        
            % Plot matrix border of matrix at isocenter
            for j = 1:stf(i).numOfRays
            
                % Compute border for every bixels
                targetPoint_vox_X_1 = stf(i).ray(j).targetPoint_bev(:,1) + pln.propStf.bixelWidth;
                targetPoint_vox_Y_1 = stf(i).ray(j).targetPoint_bev(:,2);
                targetPoint_vox_Z_1 = stf(i).ray(j).targetPoint_bev(:,3) + pln.propStf.bixelWidth;
            
                targetPoint_vox_X_2 = stf(i).ray(j).targetPoint_bev(:,1) + pln.propStf.bixelWidth;
                targetPoint_vox_Y_2 = stf(i).ray(j).targetPoint_bev(:,2);
                targetPoint_vox_Z_2 = stf(i).ray(j).targetPoint_bev(:,3) - pln.propStf.bixelWidth;
            
                targetPoint_vox_X_3 = stf(i).ray(j).targetPoint_bev(:,1) - pln.propStf.bixelWidth;
                targetPoint_vox_Y_3 = stf(i).ray(j).targetPoint_bev(:,2);
                targetPoint_vox_Z_3 = stf(i).ray(j).targetPoint_bev(:,3) - pln.propStf.bixelWidth;
            
                targetPoint_vox_X_4 = stf(i).ray(j).targetPoint_bev(:,1) - pln.propStf.bixelWidth;
                targetPoint_vox_Y_4 = stf(i).ray(j).targetPoint_bev(:,2);
                targetPoint_vox_Z_4 = stf(i).ray(j).targetPoint_bev(:,3) + pln.propStf.bixelWidth;
            
                % plot
                plot3([stf(i).sourcePoint_bev(1) targetPoint_vox_X_1],[stf(i).sourcePoint_bev(2) targetPoint_vox_Y_1],[stf(i).sourcePoint_bev(3) targetPoint_vox_Z_1],'g')
                plot3([stf(i).sourcePoint_bev(1) targetPoint_vox_X_2],[stf(i).sourcePoint_bev(2) targetPoint_vox_Y_2],[stf(i).sourcePoint_bev(3) targetPoint_vox_Z_2],'g')
                plot3([stf(i).sourcePoint_bev(1) targetPoint_vox_X_3],[stf(i).sourcePoint_bev(2) targetPoint_vox_Y_3],[stf(i).sourcePoint_bev(3) targetPoint_vox_Z_3],'g')
                plot3([stf(i).sourcePoint_bev(1) targetPoint_vox_X_4],[stf(i).sourcePoint_bev(2) targetPoint_vox_Y_4],[stf(i).sourcePoint_bev(3) targetPoint_vox_Z_4],'g')
            
                end
        
                % Plot properties
                daspect([1 1 1]);
                view(0,-90);
                xlabel 'X [mm]'
                ylabel 'Y [mm]'
                zlabel 'Z [mm]'
                title ('Beam''s eye view')
                axis([-300 300 -300 300 -300 300]);
        
            % second subplot: visualization in lps coordinate system
            subplot(1,2,2)
        
            % Plot target coordinates whitout any rotation
            plot3(coordsX,coordsY,coordsZ,'r.')
            hold on;
        
            % Rotated projection matrix at isocenter
            isocenter_plane_coor = rayPos*rotMat_vectors_T;
        
            % Plot isocenter plane
            plot3(isocenter_plane_coor(:,1),isocenter_plane_coor(:,2),isocenter_plane_coor(:,3),'y.');
        
            % Plot rotated bixels border.
            for j = 1:stf(i).numOfRays
                % Generate rotated projection target points.
                targetPoint_vox_1_rotated = [stf(i).ray(j).targetPoint_bev(:,1) + pln.propStf.bixelWidth,stf(i).ray(j).targetPoint_bev(:,2),stf(i).ray(j).targetPoint_bev(:,3) + pln.propStf.bixelWidth]*rotMat_vectors_T;
                targetPoint_vox_2_rotated = [stf(i).ray(j).targetPoint_bev(:,1) + pln.propStf.bixelWidth,stf(i).ray(j).targetPoint_bev(:,2),stf(i).ray(j).targetPoint_bev(:,3) - pln.propStf.bixelWidth]*rotMat_vectors_T;
                targetPoint_vox_3_rotated = [stf(i).ray(j).targetPoint_bev(:,1) - pln.propStf.bixelWidth,stf(i).ray(j).targetPoint_bev(:,2),stf(i).ray(j).targetPoint_bev(:,3) - pln.propStf.bixelWidth]*rotMat_vectors_T;
                targetPoint_vox_4_rotated = [stf(i).ray(j).targetPoint_bev(:,1) - pln.propStf.bixelWidth,stf(i).ray(j).targetPoint_bev(:,2),stf(i).ray(j).targetPoint_bev(:,3) + pln.propStf.bixelWidth]*rotMat_vectors_T;
            
                % Plot rotated target points.
                plot3([stf(i).sourcePoint(1) targetPoint_vox_1_rotated(:,1)],[stf(i).sourcePoint(2) targetPoint_vox_1_rotated(:,2)],[stf(i).sourcePoint(3) targetPoint_vox_1_rotated(:,3)],'g')
                plot3([stf(i).sourcePoint(1) targetPoint_vox_2_rotated(:,1)],[stf(i).sourcePoint(2) targetPoint_vox_2_rotated(:,2)],[stf(i).sourcePoint(3) targetPoint_vox_2_rotated(:,3)],'g')
                plot3([stf(i).sourcePoint(1) targetPoint_vox_3_rotated(:,1)],[stf(i).sourcePoint(2) targetPoint_vox_3_rotated(:,2)],[stf(i).sourcePoint(3) targetPoint_vox_3_rotated(:,3)],'g')
                plot3([stf(i).sourcePoint(1) targetPoint_vox_4_rotated(:,1)],[stf(i).sourcePoint(2) targetPoint_vox_4_rotated(:,2)],[stf(i).sourcePoint(3) targetPoint_vox_4_rotated(:,3)],'g')
            end
        
            % surface rendering
            if visMode == 2
                surface = patch('Faces',f,'Vertices',v);
                set(surface,'FaceColor',[0 0 1],'EdgeColor','none','FaceAlpha',.4);
                lighting gouraud;
            end
        
            % labels etc.
            daspect([1 1 1]);
            view(0,-90);
            xlabel 'X [mm]'
            ylabel 'Y [mm]'
            zlabel 'Z [mm]'
            title 'lps coordinate system'
            axis([-300 300 -300 300 -300 300]);
            %pause(1);
        end
            


            
           
            
    end
end



